#/dev/serial/by-id/usb-Klipper_rp2040_5044506120D9511C-if00

[mcu eddy]
# FOR USB: replace this with your serial port ID
# FOR CANBUS: replace this with your canbus UUID
serial: /dev/serial/by-id/usb-Klipper_rp2040_5044506120D9511C-if00
restart_method: command

[probe_eddy_ng btt_eddy]
sensor_type: btt_eddy
i2c_mcu: eddy
i2c_bus: i2c0f
x_offset: -34.25
y_offset: -14.66
probe_speed: 4.0 #- The speed at which to perform normal homing operations
lift_speed: 10.0 #- The speed at which to lift the toolhead during probing operations
move_speed: 50.0 #- The speed at which to move in the xy plane (typically only for calibration)
home_trigger_height: 2 #- The height at which the virtual endstop should trigger. A value between 1.0 and 3.0 is recommended, with 2.0 or 2.5 being good choices. This is also the height that is used for scanning operations.
calibration_z_max: 10.0 #- The maximum z value to calibrate from. 5.0 is a good default, calibrating from higher values is not needed. Calibration will automatically involve invalid values at the start and end of calibration.
#reg_drive_current: 15 #- The "drive current" for the LDC1612 sensor. This value is typically sensor specific and depends on the coil design and the operating distance. The default for BTT Eddy is 15. (A starting value can be obtained by placing the toolhead ~10mm above the bed and running LDC_NG_CALIBRATE_DRIVE_CURRENT.)
#tap_drive_current: 0 #- The "drive current" to use for tap operations. If zero or not set, reg_drive_current is used. Tapping involves reading values much closer to the print bed than basic homing, and may require a different, typically higher, drive current. For example, BTT Eddy performs best with this value at 16. Note that the sensor needs to be calibrated for both drive currents separately. Pass the DRIVE_CURRENT argument to EDDY_NG_CALIBRATE.
tap_start_z: 3.2 #- The Z position at which to start a tap-home operation. This height will need to be fine-tuned to ensure that the sensor can provide readings across the entire tap range (i.e. from this value down to tap_target_z), which in turn will depend on the tap_drive_current. When the tap_drive_current is increased, the sensor may not be able to read values at higher heights. For example, BTT Eddy typically cannot work with heights above 3.5mm with a drive current of 16 (but at drive current 15 cannot read values below 0.5mm) (Note that all of these values are in terms of offsets from the nozzle to the toolhead. The actual sensor coil is mounted higher -- but must be placed between 2.5 and 3mm above the nozzle, ideally around 2.75mm. If there are amplitude errors, try raising or lowering the sensor coil slightly.)
tap_target_z: -0.2 #- The target Z position for a tap operation. This is the lowest position that the toolhead may travel to in case of a failed tap. Do not set this very low, as it will cause your toolhead to try to push through your build plate in the case of a failed tap. A value like -0.250 is no worse than moving the nozzle down one or two notches too far when doing manual Z adjustment.
tap_mode: butter #- How to compute the tap. Options are wma (default) or butter. wma uses a moving average derivative, butter uses a Butterworth filter which will be more accurate and less sensitive to noise.
tap_threshold: 150 #- The threshold at which to detect a tap. This value is sensor and tap mode specific. For wma, the default is 1000. For butter, the default is 250. A good value can be obtained by running PROBE_EDDY_NG_TAP and examining the graph. You can also experiment to arrive at this value. A lower value will make tap detection more sensitive. A higher value will cause the detection to wait too long before recognizing a tap. You can use a manual THRESHOLD parameter to the TAP command to experiment to find a good value. You may also need to use different thresholds for different build plates.
tap_speed: 3 #- The speed at which a tap operation should be performed at. This shouldn't be much slower than 3.0, but you can experiment with lower or higher values. This shouldn't be too high, as Klipper needs some small amount of time to react to a tap trigger and the toolhead will still be moving at this speed even past the tap point. So, consider any speed you'd feel comfortable triggering a toolhead move to tap_target_z at.
tap_adjust_z: 0.1 #- A constant additional amount to add to the computed tap Z offset. Use this if the computed tap is a bit too high or too low for your taste. Positive values will raise the toolhead, negative values will lower it.
tap_samples: 3 #- The number of tap samples to consider when computing the tap offset.
tap_max_samples: 5 #- The maximum number of tap samples to take before giving up.
tap_samples_stddev: 0.025 #- The maximum standard deviation any tap_samples count samples must have in order to be considered. In other words, with the default configuration, 3 taps will be taken (tap_samples). If they have less than tap_samples_stddev, their average will be used. If they do not, additional taps will be taken up to tap_max_samples until a group of 3 samples has a low enough standard deviation.
write_tap_plot: true
write_every_tap_plot: true

[temperature_sensor btt_eddy_mcu]
sensor_type: temperature_mcu
sensor_mcu: eddy
min_temp: 10
max_temp: 100

[temperature_sensor btt_eddy]
sensor_type: Generic 3950
sensor_pin: eddy:gpio26